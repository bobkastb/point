

        1.Получить полную конфигурации сервера 
		Запрос:    http://<host:port>/cmd/config
	Результат - { result:<jsondata> }
	jsondata - Общая Конфигурация сервера (тип ServerConfig). Включает "options" и "Scheduler". То есть те части которые находяться в дополнительных файлах ( options.json , scheduler.json )
  
        2.Получить полное состояние сервера 
        Запрос:    http://<host:port>/cmd/idebug
	Результат - { result:<jsondata> }
	jsondata - снимок состояния сервера (class Server  )
	
	
        3.Получить состояние и конфигурацию планировщика сервера 
        Запрос:    http://<host:port>/cmd/schedule
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика

		4.Установка новой конфигурации целиком	
        Запрос: 	http://<host:port>/cmd/schedule/set?value=<newconfig>
				|	http://<host:port>/cmd/schedule?value=<newconfig>
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика
		"newconfig":  новая конфигурация планировщика в JSON формате

		5.Изменение конфигурации меняются только те поля, которые заданы в запросе. Этот же запрос позволяет создавать новые задания.	
        Запрос: 	http://<host:port>/cmd/schedule/update?value=<chgconfig>
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика
		"newconfig":  новая конфигурация планировщика в JSON формате

		Пример: 
		`{"Scheduler":{"Enabled":false}}`
			- В результате выполнения, планировщик остановится
		`{"Scheduler":{"Entries": [{"Id":"ID1","Duration": 7}]}
			- В результате выполнения, измениться только длительность выполнения задания "ID1"
		
		6.Получить состояние нескольких заданий
        Запрос: 	http://<host:port>/cmd/schedule/state?value={"Idlist":["<id>",...]}
				|	http://<host:port>/cmd/schedule/state?ids=<id>,...
	Результат : { servertime:unixtime , result:{ SchedulerState:{...} }, error?:string }
		"SchedulerState": состояние планировщика, в структуру включены только те задания, идентификаторы которых указаны в запросе
		Состояния заданий включают настройки, поэтому в возвращаемом результате нет поля "Scheduler". (дублирование)
		
		7.Удаление нескольких заданий
        Запрос: 	http://<host:port>/cmd/schedule/delete?value={"Idlist":["<id>",...]}
				|	http://<host:port>/cmd/schedule/delete?ids=<id>,...
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика

		Пример: 
			http://<host:port>/cmd/schedule/delete?ids=ID1,ID2
		или http://<host:port>/cmd/schedule/delete?value={"Idlist":["ID1","ID2"]}
		Выполнение любого из этих запросов. приведет к останову (если были запущены), и удалению заданий "ID1","ID2"

		8.Принудительный запуск задания 
        Запрос: 	http://<host:port>/cmd/schedule/start?value={"Idlist":["<id>",...]}
				|	http://<host:port>/cmd/schedule/start?ids=<id>,...
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика
		Если на момент получения запроса , задача уже активна(запущена), возвращается ошибка.	
		
		9.Запуск планировщика 
        Запрос: 	http://<host:port>/cmd/schedule/start
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика
		Устанавливает в значение true, параметр Scheduler.Enabled  сохраняемой конфигурации планировшика. Новая конфигурация сохраняется. Если значение Scheduler.Enabled поменялось с false на true, произойдет запуск планировщика (запуск таймера планировщика).
		Существует эквивалентный запрос update: 
			http://<host:port>/cmd/schedule/update?value={"Scheduler":{"Enabled":true}}
			
		10.Принудительный останов задания 
        Запрос: 	http://<host:port>/cmd/schedule/stop?value={"Idlist":["<id>",...]}
				|	http://<host:port>/cmd/schedule/stop?ids=<id>,...
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика
		Если на момент получения запроса , задача не активна(не запущена), возвращается ошибка.	
		
		11.Останов планировщика 
        Запрос: 	http://<host:port>/cmd/schedule/stop
	Результат : { servertime:unixtime , result:{Scheduler:{...}, SchedulerState:{...} }, error?:string }
		"Scheduler" : изменяемая и сохраняемая конфигурация планировшика (в файле scheduler.json)
		"SchedulerState": состояние планировщика
		Устанавливает в значение false, параметр Scheduler.Enabled сохраняемой конфигурации планировшика. Новая конфигурация сохраняется. Если значение Scheduler.Enabled поменялось с true на false, произойдет останов планировщика (останов таймера планировщика).
		Существует эквивалентный запрос update: 
			http://<host:port>/cmd/schedule/update?value={"Scheduler":{"Enabled":false}}


		12.Интегральный запрос к серверу. Сделан для того чтобы интегрировать несколько запросов состояния в 1. Интегрировать можно только те запросы которые не имеют параметров.
        Запрос: 	http://<host:port>/cmd/statuspolling?calls=<cmd1>,<cmd2>...
	Результат : { servertime:unixtime , 
			result:{
				<rcmd1>:{...},
				<rcmd2>:{...},
				...
				}, 
			error?:string 
			errordiff:{
				<rcmd1>:"...",
				<rcmd2>:"...",
				...
			}
		}
		Расшифровка параметров:
		<cmd1> - идентификатор первого запроса. например -  capture/files , (префикс "/cmd/" нужно не приписывать)
		<rcmd1> - модифицированный идентификатор первого запроса, в котором символ "/" заменен на "_" (можно и не делать замену - это обсуждаемо)
		error - здесь просто сложение строк-ошибок
		errordiff - дифференциирование строк ошибок по типу запроса
		
		Внутри структуры result.<rcmd1> будет то что возвращается после запроса http://<host:port>/cmd/<cmd1> , в поле "result"
		Если параметр calls не задан - смотреть пример ниже.
			
		Например последовательность запросов "cmd/capture/state","cmd/capture/files","cmd/switch/state","cmd/schedule" может быть заменена одним 
					http://<host:port>/cmd/statuspolling
			или 	http://<host:port>/cmd/statuspolling?calls=capture/state,capture/files,switch/state,schedule


		13. Запрос /cmd/switch/state
		Пример ответа 
		{"result":{
			"Audio":{"1":2,"2":2,"3":2,"4":4,"5":5,"6":6,"7":7,"8":8},
			"Video":{"1":2,"2":2,"3":2,"4":9,"5":5,"6":6,"7":7,"8":8},
			"AFV":true,
			"ActiveInputs":[1,1,1,0,0,0,0,0],
			"ActiveOutputs":[1,1,1,0,0,0,0,0]
			"DiagnosticMessages?":{...} //диагностические сообщения, описание в приложении
			Controlled?:boolean  	( cfg.SerialPortFileName!="" - Управляемость коммутатора   ) 
			port?:string,			( системный путь к порту управления камерой )
		}		
		Расшифровка ответа
		"Audio" - Карта сопоставления звуковых выходов и входов. <выход>:<вход>
		"Video" - Карта сопоставления видео выходов и входов. <выход>:<вход>
		"ActiveInputs" - Индексы масивы начинаются с 1. Каждый индекс соотвествует номеру "входа". Значение 0 означает что устройство не подключено. Другое значение означает, что устройство - подключено.
		"ActiveOutputs" - Индексы масивы начинаются с 1. Каждый индекс соотвествует номеру "выхода". Значение 0 означает что устройство не подключено. Другое значение означает, что устройство - подключено.
		
		Расшифровка состояния.
		 port - пустая строка - не задан порт управления
		 Controlled - может быть false при заданном порте управления. В этом случае смотреть содержимое DiagnosticMessages
		
		13.Получить список камер 
    Запрос: http://<host:port>/cmd/cam/cameras
	Результат : { 
		result:[
			...{ ... } // состояние камеры см. cmd/cam/state?id=<id>
			}
		], 
		error?:string 
		}
		Расшифровка параметров:
		error - ошибка

		14. Получить конфиг целиком
    Запрос: http://<host:port>/cmd/config
	Результат : { 
		result:{...}	( Конфиг config.json , с добавлением scheduler.json , и options.json  )
		error?:string 	()
		}
	Использовать этот запрос только в целях отладки. Структура 	результата не гарантированна.
	
		15. Получить содержимое сервера целиком
    Запрос: http://<host:port>/cmd/idebug?value=<path>
			http://<host:port>/cmd/idebug
	Результат : { 
		result:{...}	( содержимое )
		error?:string 	( как обычно)
		}
		Расшифровка параметров:
		<path> - путь внутри сервера, с каждым днем - структура растет.
		Например 
		http://192.168.77.40:8126/cmd/idebug?value=scheduleSrv	 - покажет содержимое сервиса планировщика
		http://192.168.77.40:8126/cmd/idebug?value=scheduleSrv/tasks  - покажет содержимое списка задач сервиса планировщика
	Использовать этот запрос только в целях отладки (посмотреть данные на сервере). Структура 	результата не гарантированна.

		16.Получить состояние камеры 
    Запрос: http://<host:port>/cmd/cam/state?id=<id>
	Результат : { 
		result: структура "Состояние камеры" (см приложение)
		error?:string 
		}
		Расшифровка параметров:
		<id> - идентификатор камеры. Если шв неправильный вернет error="Invalid camera ID"

		Расшифровка состояния	
		port - пустая строка - не задан порт управления
		Controlled -(Управляемость) может быть false при заданном порте управления. В этом случае смотреть содержимое DiagnosticMessages
		Pin_SwitchIn - отсутствие параметра означает что, в конфигурационном файле не отражено подключение камеры к коммутатору

		
		17.Начать поворотное движение камеры 
    Запрос: http://<host:port>/cmd/cam/driveStart?id=<id>&dir=<dir>[&speed=<speed>]
	Расшифровка параметров:
		id  	: строка.ID камеры
		dir 	: строка. Допустимые значения: UP,DOWN,LEFT,RIGHT,UPLEFT,UPRIGHT,DOWNLEFT,DOWNRIGHT,STOP
		speed 	: число от 1 до 0x18
	
	Ошибки:	
        `неправильное направление движения камеры '${dir}'`
        `неправильная скорость движения камеры '${speed}'`;
		"Invalid camera ID"
	Результат
		{
		error? 		Ошибка
		state?		Состояние камеры (см приложение)
		}
		
		18.Запомнить положение/состояние камеры  
    Запрос: http://<host:port>/cmd/cam/preset/add?id=<id>&name=<name>
	Результат : { 
		result:{
			ID: 		|	строка.ID камеры
			Name: 		|	строка. Имя пресета
			softData?:{	
				ZoomPos?:,		| число. коэффициент оптического увеличения		
				FocusPos?:,		| число. Фокусное расстояние в спец. еденицах
				FocusAuto?:,	| bool.  Автоматичская фокусировка . FocusPos не будет использован при восстановлении
				PanTiltPos?:,	| [Pan,Tilt] -  панорамный и наклонный угол поворота камеры 
			};
		}, 
		error?:string 
		}
	
	Расшифровка параметров:
		id  	: строка.ID камеры
		name 	: строка. Имя пресета
		speed 	: число от 1 до 0x18
	
	Ошибки:	
        `неправильное направление движения камеры '${dir}'`
        `неправильная скорость движения камеры '${speed}'`;
		"Invalid camera ID"
	Примечание:
		Если используется память камеры, то ID будет числовым от 0 до 0x7f
		Если память на камере будет заполнена, то она не будет использоваться. При этом ID пресета примет вид <ID камеры>-<unixtime>
		если ID пресета будет не числовым (например - исправили в конфиге), то восстановление состояния будет непосредственное, без операций с памятью камеры. 
		Будут использованы поля структуры softData
	
		18.Получить параметры состояния камеры  
	Запрос:		
		/cmd/cam/getdata?id=<id>&value=<plist>[&name=<name>]
		/cmd/cam/getdata?id=<id>[&name=<name>]		// равносильно /cmd/cam/getdata?value=FocusPos,ZoomPos,PanTiltPos
	Расшифровка параметров:
		id  	: строка.ID камеры
		name	: строка. Любая строка. "адрес памяти" для сохранения полученных данных.  
		plist 	: строка.Множество идентификаторов затребованных параметров, разделенных запятыми.
					FocusPos,ZoomPos,PanTiltPos,UserTagId,MaxSpeed (см. также - "параметры камеры" )
					
	Результат : { 
		Результат формируется в зависимости от потребностей указанных в параметре plist. Если указана потребность ZoomPos, то в ответе будет поле ZoomPos.
		result:{
			ZoomPos?:,		| число. коэффициент оптического увеличения		
			FocusPos?:,		| число. Фокусное расстояние в спец. еденицах
			FocusAuto?:,	| bool.  Автоматичская фокусировка . FocusPos не будет использован при восстановлении
			PanTiltPos?:	| [Pan,Tilt] -  панорамный и наклонный угол поворота камеры 
			UserTagId		| идентификатор камеры в памяти устройства
			...
			};
		}, 
		error?:string 
		}
	Примечание: В отличии от запроса /cmd/cam/state , данный запрос будет обращаться непосредственно к камере, поэтому его исполнение будет более долгим	
	Комбинация запросов { /cmd/cam/getdata , /cmd/cam/setdata }, дает возможность получать/записывать любые векторные данные
	
	
		19.Установить параметры состояния камеры  
	Запрос:		
		/cmd/cam/setdata?id=<id>&value={ ZoomPos?,FocusPos?,FocusAuto?,PanTiltPos? ... }
		/cmd/cam/setdata?name=<name>
	Расшифровка параметров:
		id  	: строка.ID камеры
		value	: JSON сериализация структуры описанной в результатах запроса getdata ( пункт 18)
		name	: использовать данные предварительно сохраненные запросом getdata 
	Результат : { 
		Результат формируется в зависимости от потребностей указанных в параметре plist. Если указана потребность ZoomPos, то в ответе будет поле ZoomPos.
		В остальном , результат - идентичен результату запроса getdata
	Ошибки:	
		"Invalid camera ID"
		Примечание:
		При установке углов поворота, будет использована максимальная скорость
		
		20. Установить Hardware идентификатор камеры
		Запрос:		/cmd/cam/savehardinfo
		У камеры существует 2-х байтовый Hardware идентификатор.
		После вызова, этот Идентификатор будет равен =первые байты от MD5(cfg.ID), где cfg.ID это идентификатор камеры заданны в конфиге

		21.Установить глобальную позицию
	Запрос:		
		/cmd/cam/setglobalposition?id=<id>&pos=<xpos>,<ypos>
	Расшифровка параметров:
		id  	: строка.ID камеры
		xpos 	: 0..1 		// 0 - крайне левое положение, 1- крайне правое положение
		ypos 	: 0..1 		// 0 - крайне нижнее положение, 1- крайне верхнее положение
	Результат : { 
		error: 		// описание ошибки
		result: 	resCameraOperation (см ниже)
		}
		Предназначена для работы с панорамным снимком. xpos,ypos это как раз относительные координаты точки внутри панорамного снимка.
		xpos,ypos - это новыая позиция камеры.

		22.Установить относительную позицию
	Запрос:		
		/cmd/cam/setposition?id=<id>&posFrom=<xpos>,<ypos>&posTo=<xpos>,<ypos>&zoom_abswheel=<zoomwheel>
	Расшифровка параметров:
		id  	: строка.ID камеры
		xpos 	: -0.5 .. +0.5 		// -0.5 - крайне левое положение, +0.5 - крайне правое положение
		ypos 	: -0.5 .. +0.5 		// -0.5 - крайне нижнее положение, +0.5 - крайне верхнее положение
		zoomwheel: -120..120			// Относительная величина, но  0 - соотвествует минимальному увеличению (1), 120 - максимальному (12 раз).
	Результат : { 
		error: 		// описание ошибки
		result: 	resCameraOperation (см ниже)
		}
		Запрос устанавливает позицию в пределах текущего кадра, позиция камеры изменяется так чтобы после перемещения точка posFrom, переместилась в точку posTo.
		zoomwheel - Отрицательная величина - уменьшает, положительная - увеличивает коэффициент увеличения.
		Зависимость коэффициента увеличения от zoomwheel - нелинейная (логарифмическая в положительной определенности zoomwheel)
		Практическое использование zoomwheel - это величина на которую прокручивается колесо мыши

		23.Сделать панорамный снимок
	Запрос:		
		/cmd/cam/makepanorama?id=<id>
	Расшифровка параметров:
		id  	: строка.ID камеры
	Результат : { 
		error: 		// описание ошибки
		result: 	resCameraOperation (см ниже)
	}
	Файл снимка доступен через result.state.PanoramaApiPath . То есть после вызова всех процедур возвращающих rCameraState (состояние камеры)
	
		24. Запрос состояния с большим ожиданием.  (Long-Polling)
	Запрос:		
		/cmd/pollingstate?sessionid=<sessionid>
	Расшифровка параметров:
		sessionid  	: идентификатор сессии. Идентификатор сессии не должен меняться в течении "жизни" клиента, идентификатор сессии должен меняться после перезапуска клиента. 
					Обеспечение уникальности - на стороне клиента.
	Результат : { 
		error: 		// описание ошибки
		result: {	
            switch?: То же что и в поле result запроса "cmd/switch/state"   (состояние коммутатора)  
			schedule:То же что и в поле result запроса "cmd/schedule/state  ( состояние планировщика ) 
            capture:То же что и в поле result запроса "cmd/capture/state  ( состояние видео-захвата ) 
            capturefiles:То же что и в поле result запроса "cmd/capture/files  ( список файлов (массив имен файлов) ) 
            camera: массив из состояний разных камер почти тоже самое что возвращается поле result запроса "cmd/cam/cameras
					только не для всех камер, а для тех у которых чтото изменилось. Сейчас отслеживается только изменение поля ActiveCapture
		}
	}
					
	Назначение:
		Возвращает изменения в состоянии компонентов сервера. Если запрос завершается, клиент должен создать новый с тем же sessionid. Если в течении 5 минут этого не сделано,
	то сессия будет "потеряна", и тот же sessionid через 15 минут - будет воспринят как новый. Отличие от других полинг-запросов (например cmd/switch/state), только в том , что 
	результат cmd/pollingstate , возвращается не сразу, а только при изменении состояния (например - изменении состояния коммутатора)
		"Новая" сессия, начинается с возврата полного состояния. То есть для того чтобы гарантировано обновить состояние - нужно просто поменять идентификатор. 
	При этом даже можно не дожидаться  завершения текущего запроса.
		
		
===============================

Для отладки , используем параметр EmulateTask . Для работы эмулятора нужен файл ".\data\template\image.mp4" с любым содержимым

---------------------------  возвращаемый результат команд камеры (resCameraOperation) -------------
Структура возвращаемая запросами /cmd/cam/setglobalposition, /cmd/cam/setposition, "/cmd/cam/zoomStart","/cmd/cam/zoomStop","/cmd/cam/driveStart","/cmd/cam/driveStop"
resCameraOperation{
    operation?:				// Данные проведенной операции
    result?:string			// оценка результата	
    error?:string			// ошибка
    state?:rCameraState;	// состояние камеры (см ниже)
	truncate:rCameraData	//Параметры камеры ( см /cmd/cam/getdata ) . 
							Установленные параметры означают что при операции выполнялось обрезание в соответствии с пределами возможного.
							Значение -1 соответствует обрезанию по нижней границе, +1 - по верхней границе, 0 - обрезание не проводилось
							Например PanTiltPos==[-1,0] - что новые вычисленные координаты камеры были обрезаны по левой границе , 
}



 --------------------------  Конфигруация планировщика -----------------------
  "Scheduler": {
   "Enabled": 			boolean, 	||  Разрешает/запрещает работу планировшика
   "PeriodResolution": 	number,  	||  Разрещаюшая способность планировщика по времени (в секундах) - период рабочего таймера 
   "TaskHistoryFormat": string,		||  Лог в JSON формате (Будет записан файл .\logs\schelude-task\task.<id>.json)
   "EmulateTask": 		boolean,	||	Эмулятор выполнения задачи. Результатом каждого задания будет MP4 файл,скопированный из					
									|| ".\data\template\image.mp4"
   "Entries": [
    {
     "Id": "ID1",
     "Duration": 7,
     "Period": 20,
     "Start": 1000,
     "Name": "name1",
     "Camera": "1",
     "FileTemplate": "filecamera id1",
     "Allowed": true
    },
	}
--------------------------  Состояние планировщика -----------------------
   "SchedulerState": {
   "isExecute": boolean		| Планировщик активен/неактивен
   "tasks": {				| Мапа состояний задач планировщика
    "ID1": {
     "state": "notrun",		| Состояние задачи планировщика одно из ["notrun","Running","PendingStart","PendingEnd"]
     "last_starttime": 0,	| Время (unixtime) последнего запуска
     "curr_duration": 0,
     "curr_file": "",		| Файл в который будет записано текушее выполнение,или предыдущее
     "next_starttime":		| Время (unixtime) следующего запуска
     "next_duration": 7,
     "cnt_calls": 0,
     "cnt_errcalls": 0,
     "Id": "ID1",
     "ApiPath_LogFile": 	| Апи-путь к файлу тектового журнала задания	
     "ApiPath_LogJsonFile": | Апи путь к файлу журнала задания в формате json 
    }],
   "ScheluderSettings": {
    "ParamsFile": 			| Путь к файлу настроек планировщика
    "JournalPath": 			| Путь к папке хранения журналов
    "ApiPath_LogFiles": 	| Апи-путь к папке хранения журналов
    "ApiPath_LogJsonFiles": | Апи-путь к папке хранения журналов в Json формате
	},
------------------------  DiagnosticMessages -----------------------
			DiagnosticMessages:{   	( диагностические сообщения см. также /cmd/cam/cameras , /cmd/switch/state , /cmd/cam/state )
				IdError?:string[];  ( возникает если hardware идентификатор на камере, не соотвествует cfg.ID )
				IdSet?:string[];	возникает если hardware идентификатор на камере не установлен (имеет значение 0). Это не ошибка - предупреждение, 
					о невозможности авто-контроля правильности подключения камеры. Он (hardware идентификатор) устанавливается запросом /cmd/cam/savehardinfo 	
				SerialError?:string;
				InitError?:string; // ошибка при инициализации , обычно при начале работы с последовательным портом: орткрытие файла порта, начальное получение данных и т.п
								// после этой ошибки порт "закрывается" и устройство становиться неуправляемым
				}

---------------------- Состояние камеры ------------------	
		{
			
			ID:string 				(cfg.ID) 
			Name:string 			(cfg.DisplayName)  
			Controlled:boolean  	( cfg.SerialPortFileName!="" - Управляемость камеры   ) 
			Pin_SwitchIn:string 	( число в строке. Номер входа этой камеры на коммутаторе  )
			DiagnosticMessages?:{...} //диагностические сообщения, описание в приложении
			ActiveCapture:boolean
		
			port?:string,			( системный путь к порту управления камерой )
			speedRange?:[lo,hi],	( [минимальная,максимальная]  сорость поворотов )
			speed?:number,			( текущая скорость поворотов )
			readAnswers?:boolean,	( Чтение ответов камеры по компорту )
			current_preset?:string; ( идентификатор последнего используемого пресета ) 
			Presets: {}				( все пресеты камеры . содержимое presets_<ID>.json , возвращается также запросом "/cmd/cam/preset/get" )
			error?:string;
			PanoramaApiPath:string	// Апи путь к файлу панорамы (*.jpg) Нынешний файл панорамы имеет размер 7680*1080 точек
									// отсутствие этого параметра означает что панорамного сника - нет
			camdata?:{
				... //Параметры камеры ( см /cmd/cam/getdata ) . Внутренние параметры PanTiltPos_h и ZoomPos_h возвращают текущую позицию камеры в человеческих еденицах
				PanTiltPos_h 		// градусы поворотов [x,y]
				ZoomPos_h			// коэффициент увеличения
				PanTiltPos_pan 		// координаты камеры в окне панорамы [0..1,0..1] - должны соответствовать координатам в запросе /cmd/cam/setglobalposition после выполнения последнего
			}						
			limits:{ 				// Возвращается только в запросах /cmd/cam/state и /cmd/cam/cameras
					"Zoom":[ min , max ]  // Обычно увеличение в 1..12 раз
					"Pos": { 
						"x":[-100,100] ,  // Пределы по горизонтали в градусах
						"y":[-30,30] }	  // Пределы по вертикали в градусах	
					}
			}
		], 

		Состояние работоспособности камеры определяется 3 параметрами 
		port 			- пустая строка - не задан порт управления
		Controlled 		-(Управляемость) может быть false при заданном порте управления. В этом случае смотреть содержимое DiagnosticMessages
		Pin_SwitchIn 	- отсутствие параметра означает что, в конфигурационном файле не отражено подключение камеры к коммутатору
		ActiveCapture - влияет на картинку в закладке камеры. Если ActiveCapture==false - то изображения быть не должно
		
		Особенности отображения
		1) При отсутствии подключения к коммутатору (Pin_SwitchIn) , вместо (или поверх) изображения с камеры (на вкладке камеры), необходимо выводить не блокирующее сообщение 
		о том что "Видеопоток с данной камеры , не может быть получен"
		2) При Controlled=false|undefined , кнопки управления камерой и пресеты должны быть заблокированны, и при попытке нажать на них, должно выскакивать сообщение об ошибке-
			"Камера не управляема"
			Кроме этого , в этом состоянии , должно быть постоянное извещение пользователя о "неуправляемости камеры", содержимое этого сообщения напрямую зависит 
			от поля DiagnosticMessages и поля port. Пустое поле port - означает , что "Не задан порт управления камерой"
		Таким образом в "неуправляемости" нужно выделить 2 состояния
			2.1) не задан порт
			2.2) ошибка при открытии порта , ошибка при обмене данными с устройством. В этом случае , подробности должны быть взяты из поля DiagnosticMessages.InitError
			
		
		
---------------------- Состояние коммутатора ------------------	
		Определяется 2 параметрами 
		 port - пустая строка - не задан порт управления
		 Controlled - может быть false при заданном порте управления. В этом случае смотреть содержимое DiagnosticMessages

		Таким образом в "неуправляемости" нужно выделить 2 состояния
			1) не задан порт
			2) ошибка при открытии порта , ошибка при обмене данными с устройством. В этом случае , подробности должны быть взяты из поля DiagnosticMessages.InitError
			
		В обоих случаях, следует заблокировать объекты-контролы управления коммутатором (в том числе пресеты), поверх обычной картинки,
		разместить картинку-предупреждение об ошибке "неуправляемости" (возможно прозрачную и меньшего размера чем таблица коммутатора )
		
